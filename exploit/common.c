/*
 * ra1npoc - exploit/common.c
 *
 * Copyright (c) 2021 - 2023 kok3shidoll
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#include <io/iousb.h>
#include <common/log.h>
#include <common/common.h>

#if defined(RA1NPOC_MODE)
RA1NPOC_API transfer_t USBReqStall(client_t *client)
{
    return IOUSBControlTransferTO(client, 2, 3, 0x0000, 128, NULL, 0, 10);
}

RA1NPOC_API transfer_t USBReqLeak(client_t *client, unsigned char* blank)
{
    return IOUSBControlTransferTO(client, 0x80, 6, 0x0304, 0x040a, blank, EP0_MAX_PACKET_SZ, 1);
}
#endif

RA1NPOC_API transfer_t sendData(client_t *client, unsigned char* buf, size_t size)
{
    return IOUSBControlTransfer(client, 0x21, 1, 0x0000, 0x0000, buf, size);
}

RA1NPOC_API transfer_t sendDataTO(client_t *client, unsigned char* buf, size_t size, int timeout)
{
    return IOUSBControlTransferTO(client, 0x21, 1, 0x0000, 0x0000, buf, size, timeout);
}

RA1NPOC_API transfer_t getStatus(client_t *client, unsigned char* buf, size_t size)
{
    return IOUSBControlTransfer(client, 0xa1, 3, 0x0000, 0x0000, buf, size);
}

RA1NPOC_API transfer_t sendAbort(client_t *client)
{
    return IOUSBControlTransferTO(client, 0x21, 4, 0x0000, 0x0000, NULL, 0, 0);
}

#if defined(RA1NPOC_MODE)
RA1NPOC_API const char *IOReturnName(IOReturn res)
{
    if(res == kIOReturnSuccess)
        return "Success";
    if(res == kIOReturnTimeout || res == kIOUSBTransactionTimeout)
        return "Timeout";
    if(res == kIOUSBPipeStalled || res == kUSBHostReturnPipeStalled)
        return "PipeStalled";
    if(res == kIOReturnNotResponding)
        return "NotResponding";
    if(res == kIOReturnNoDevice)
        return "NoDevice";
    if(res == kIOReturnAborted)
        return "Aborted";
    if(res == kIOReturnError)
        return "Error";
    
    return "Unknow";
}

RA1NPOC_API int isStalled(IOReturn res)
{
    if(res == kIOUSBPipeStalled || res == kUSBHostReturnPipeStalled)
        return 1;
    return 0;
}

RA1NPOC_API int isTimeout(IOReturn res)
{
    if(res == kIOReturnTimeout || res == kIOUSBTransactionTimeout)
        return 1;
    return 0;
}

RA1NPOC_API void preRetry(client_t *client, unsigned int i)
{
    __unused transfer_t result;
    memset(&blank, '\x0', EP0_MAX_PACKET_SZ);
    
    DEVLOG("Retry %d", i);
    usleep(10000);
    result = sendData(client, blank, EP0_MAX_PACKET_SZ); // send blank data and redo the request.
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    usleep(10000);
}
#endif

// function used when there is no bug in A9
RA1NPOC_API int sendPongo_orig(client_t *client, const void* pongoBuf, const size_t pongoLen)
{
    __unused transfer_t result;
    
    {
        size_t len = 0;
        size_t size;
        while(len < pongoLen)
        {
            size = ((pongoLen - len) > DFU_MAX_TRANSFER_SZ) ? DFU_MAX_TRANSFER_SZ : (pongoLen - len);
            result = sendData(client, (unsigned char*)&pongoBuf[len], size);
            DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
            if(result.wLenDone != size || result.ret != kIOReturnSuccess)
            {
                ERR("Failed to send pongoOS");
                return -1;
            }
            len += size;
        }
    }
    result = sendAbort(client);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    return 0;
}

RA1NPOC_API int sendPongo(client_t *client, const void* pongoBuf, const size_t pongoLen)
{
    __unused transfer_t result;
    
    {
        size_t len = 0;
        size_t size;
        while(len < pongoLen)
        {
        retry:
            size = ((pongoLen - len) > DFU_MAX_TRANSFER_SZ) ? DFU_MAX_TRANSFER_SZ : (pongoLen - len);
            result = sendDataTO(client, (unsigned char*)&pongoBuf[len], size, 1000);
            DEVLOG("send[0x%08x/0x%08x] size:0x%08x -> result: 0x%04x (%s)", (int)len, (int)pongoLen, (int)size, result.ret, IOReturnName(result.ret));
            if((result.ret == kIOReturnTimeout) || (result.ret == kIOUSBTransactionTimeout))
            {
                // checkra1n 0.1337.1 has a bug that sometimes causes packet transmission on yoloDFU to fail for A9 devices
                // if we get a timeout here, it should work simply by starting over, since it has not actually been sent yet.
                DEVLOG("Timeout to send[0x%08x/0x%08x] size:0x%04x, retry this", (int)len, (int)pongoLen, (int)size);
                usleep(10000);
                goto retry;
            }
            if(result.wLenDone != size || (result.ret != kIOReturnSuccess))
            {
                // what we encounter here is clearly a failure.
                ERR("Failed to send pongoOS");
                return -1;
            }
            len += size;
        }
    }
    
    // send abort and boot pongoOS
    result = sendAbort(client);
    DEVLOG("Send abort -> result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    return 0;
}
